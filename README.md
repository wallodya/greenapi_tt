# Тестовое задание для GreenAPI

В ТЗ не был указан конкретный функционал (задание), который должен выполнять сервис М2, поэтому для наглядности он просто складывает два числа, которые передаются сервису М1 через query-парамерты ("a" и "b") GET запроса.

### Например:

1. Делаем GET запрос `localhost:5000?a=1&b=2`
2. Сервис М1 парсит параметры и передает в очередь
3. Сервис М2 "принимает" сообщение с параметрами и обрабатывает (складывает два числа)
4. Сервис М2 передает результат в очередь (задана параметром replyTo у входящего сообщения)
5. Сервис М1 принимает результат и отправляет его в качестве ответа на GET запрос

*Примечание: для реализации RPC функионала используется уникальный correlationId, с помощью которого сервис М1 понимает для какой именно операции (задачи) пришел результат.*


## Локальный запуск

Приложение контейнеризированно, поэтому для запуска достаточно склониировать репозиторий и выполнить команду `docker compose up` в директории проекта.

"Приложение" состоит из трех контейнеров: м1, м2 и rabbitmq. 

Открыты два порта:
- `5000`: для отправки запросов в сервис М1
- `5672`: для доступа в дашборд rabbitmq

*Примечание: поскольку для корректного запуска сервисов должен быть запущен rabbitmq, выполняется `healthcheck` контейнера с брокером (проверяем, занущен ли rabbitmq внутри контейнера), поэтому запуск контейнеров с сервисами может занять некоторое время*

## Логирование

Для удобства docker синхронизирует логи из контейнера с брокером с локальной директорией `logs` (через docker-volume, настроена в `docker-compose.yml`).
Логи из Node.js сервисов, просто выводятся в консоль.

Для наглядности некоторые категории логов выделены в отдельные файлы.

Конфигурация выполнена в файле `rabbitmq.conf`.

*Примечание: приложение очень простое, поэтому почти все логи связаны с запуском брокера, либо подключением узлов (сервисов)*